apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-alloy-traces
  namespace: monitoring
data:
  config.alloy: |
    // OtelCol configs
    logging {
        level  = "debug"
        format = "json"
    }

    otelcol.auth.basic "tempo" {
      username = 406010
      password = "eyJrIjoiNGRjNDU3MmQ1MTVlOTk2ODQ1Zjk1MGNmZDcwNGQyMmIwOGEwNjA3MyIsIm4iOiJyb2dtZW4tcHVibGlzaGVyIiwiaWQiOjgxNDMyMn0="
    }
    otelcol.auth.basic "promp" {
      username = 406010
      password ="eyJrIjoiNGRjNDU3MmQ1MTVlOTk2ODQ1Zjk1MGNmZDcwNGQyMmIwOGEwNjA3MyIsIm4iOiJyb2dtZW4tcHVibGlzaGVyIiwiaWQiOjgxNDMyMn0="
    }

    otelcol.receiver.otlp "receiverbase" {
      grpc {
        endpoint = "0.0.0.0:4317"
      }
      http {
        endpoint = "0.0.0.0:4318"
      }      
      output {
        metrics = [otelcol.processor.batch.processorbatch.input]
        logs    = [otelcol.processor.batch.processorbatch.input]
        traces  = [otelcol.processor.memory_limiter.memory_limiter.input]
      }
    }

    otelcol.processor.memory_limiter "memory_limiter" {
      check_interval = "5s"
      limit = "400MiB"        // Hard Limit
      spike_limit = "100MiB"  // Soft Limit = Hard Limit - spike_limit = 300MiB
      output {
        //traces  = [otelcol.processor.filter.default.input]
        traces  = [otelcol.processor.resourcedetection.default.input]

      }
    } 

    // Resource Detection Processor
    otelcol.processor.resourcedetection "default" {
      detectors = ["env","system"]
  
      system {
        hostname_sources = ["os"]
      }
  
      output {
        metrics = [otelcol.processor.k8sattributes.default.input]
        logs = [otelcol.processor.k8sattributes.default.input]
        traces = [otelcol.processor.k8sattributes.default.input]
      }
    }

    // K8s Attributes Processor
    otelcol.processor.k8sattributes "default" {
      extract {
        metadata = ["k8s.namespace.name","k8s.pod.name","k8s.deployment.name","k8s.statefulset.name","k8s.daemonset.name","k8s.cronjob.name","k8s.job.name","k8s.node.name","k8s.pod.uid","k8s.pod.start_time"]
      }
      pod_association {
        source {
          from = "resource_attribute"
          name = "k8s.pod.ip"
        }
        source {
          from = "resource_attribute"
          name = "k8s.pod.uid"
        }
        source {
          from = "connection"
        }
      }
  
      output {
        metrics = [otelcol.processor.transform.default.input]
        logs = [otelcol.processor.transform.default.input]
        traces = [otelcol.processor.transform.default.input, otelcol.connector.host_info.default.input]
      }
    }

    // Host Info Connector
    otelcol.connector.host_info "default" {
      host_identifiers = [ "k8s.node.name" ]
  
      output {
        metrics = [otelcol.processor.batch.processorbatch.input]
      }
    }
  
    // Transform Processor
    otelcol.processor.transform "default" {
      error_mode = "ignore"
      log_statements {
        context = "resource"
        statements = [
          "set(attributes[\"pod\"], attributes[\"k8s.pod.name\"])",
          "set(attributes[\"namespace\"], attributes[\"k8s.namespace.name\"])",
          "set(attributes[\"loki.resource.labels\"], \"cluster, namespace, job, pod\")",
        ]
      }
  
      output {
        metrics = [otelcol.processor.batch.processorbatch.input]
        logs = [otelcol.processor.batch.processorbatch.input]
        traces = [otelcol.processor.filter.default.input]
      }
    }

    otelcol.processor.filter "default" {
      error_mode = "ignore"
      traces {
        span = [
          "IsMatch(attributes[\"http.route\"], \".*prometheus.*\")",
          "IsMatch(attributes[\"http.route\"], \".*health.*\")",
          "IsMatch(attributes[\"http.target\"], \".*health.*\")",
          "IsMatch(attributes[\"http.target\"], \".*health_check.*\")",
          "IsMatch(attributes[\"db.operation\"], \".*PING.*\")",
          "IsMatch(attributes[\"express.type\"], \".*middleware.*\")",
          "IsMatch(attributes[\"express.type\"], \".*router.*\")",
          "IsMatch(attributes[\"db.operation\"], \".*EXIST.*\")",
          "IsMatch(attributes[\"express.name\"], \".*request handler.*\")",
          "IsMatch(attributes[\"net.peer.port\"], \".*9000.*\")",
          "IsMatch(attributes[\"db.system\"], \".*redis.*\")",
        ]
      }

      output {
        traces  = [otelcol.processor.transform.rogmen_traces.input]
      }
    }

    otelcol.processor.transform "rogmen_traces" {
      error_mode = "ignore"
      trace_statements {
        context = "resource"
        statements = [
          "set(attributes[\"cluster\"], \"autopilot-cluster-app\")",
          "set(attributes[\"k8s.cluster.name\"], "autopilot-cluster-app\")" ,
        ]
      }
    
      output {
        traces = [otelcol.processor.batch.processorbatch.input]
      }
    }

    prometheus.exporter.self "self_metrics" {}

    prometheus.scrape "scrape_self" {
      targets    = prometheus.exporter.self.self_metrics.targets
      forward_to = [otelcol.receiver.prometheus.prom_to_otlp.receiver]
    }

    otelcol.receiver.prometheus "prom_to_otlp" {
      output {
        metrics = [otelcol.processor.batch.processorbatch.input]
      }
    }
    otelcol.processor.batch "processorbatch" {
      timeout = "10s"
      send_batch_size = 10000
      send_batch_max_size = 11000
      output {
        metrics = [otelcol.exporter.otlp.basetotlp.input]
        logs    = [otelcol.exporter.otlp.basetotlp.input]
        traces  = [otelcol.exporter.otlp.basetotlp.input]
      }
    }

    otelcol.exporter.prometheus "default" {
      forward_to = [prometheus.remote_write.metrics_hello_observability.receiver]
    }

    otelcol.exporter.otlp "basetotlp" {
      client {
        endpoint = "https://tempo-us-central1.grafana.net:443"
        auth     = otelcol.auth.basic.tempo.handler
        tls {
          insecure = false
          insecure_skip_verify = false
        }
      }
      
    }

    
    // Prometheus configs
    prometheus.remote_write "metrics_hello_observability" {
      external_labels = {
        monitor = "hello-observability",
        cluster = "autopilot-cluster-app",
      }
      endpoint {
        name = "hello-observability-6397c4"
      url  = "https://prometheus-us-central1.grafana.net/api/prom/push"
      basic_auth {
        username = "821057"
        password = "eyJrIjoiNGRjNDU3MmQ1MTVlOTk2ODQ1Zjk1MGNmZDcwNGQyMmIwOGEwNjA3MyIsIm4iOiJyb2dtZW4tcHVibGlzaGVyIiwiaWQiOjgxNDMyMn0="
      }
      }
    }

    tracing {
      sampling_fraction = 0.8
      write_to = [otelcol.processor.tail_sampling.tail_sampling_default.input]
    }

    otelcol.processor.tail_sampling "tail_sampling_default" {
      decision_wait               = "10s"
      num_traces                  = 50000
      expected_new_traces_per_sec = 5000
      policy {
        name = "all_traces_above_1000ms"
        type = "latency"
        latency {
          threshold_ms = 1000
        }
      }
      policy {
        name = "sampling_percentage_probabilistic"
        type = "probabilistic"
        probabilistic {
            sampling_percentage = 10
        }
      }
      policy {
        name = "policy_status_code"
        type = "status_code"
        status_code {
          status_codes = ["ERROR", "UNSET"]
        }
      }
      policy {
        name = "policy_rate_limiting"
        type = "rate_limiting"
        rate_limiting {
          spans_per_second = 100
        }
      }	
      output {
        traces = [otelcol.exporter.otlp.basetotlp.input]
      }
    }
    // otelcol.processor.probabilistic_sampler "probabilistic_sampler_default" {
    //   sampling_percentage = 15
    //   output {
    //     logs = [otelcol.exporter.otlp.basetotlp.input]
    //     traces = [otelcol.exporter.otlp.basetotlp.input]
    //   }
    // }

    // otelcol.processor.transform "service_name" {
    //   error_mode = "ignore"
    //  trace_statements {
    //     context = "resource"
    //     statements = [
    //       `replace_pattern(attributes["k8s.replicaset.name"], "-[0-9a-zA-Z]+$", "")`,
    //       `set(attributes["service.name"], attributes["k8s.replicaset.name"])`,
    //     ]
    //   }
    //   output {
    //     traces  = [otelcol.processor.transform.service_name_span.input]
    //   }
    // }
    
    // otelcol.processor.transform "service_name_span" {
    //   error_mode = "ignore"
    //   trace_statements {
    //     context = "span"
    //     statements = [
    //       `replace_pattern(attributes["k8s.replicaset.name"], "-[0-9a-zA-Z]+$", "")`,
    //       `set(attributes["service.name"], attributes["k8s.replicaset.name"]) where attributes["service.name"] == nil`,
    //     ]
    //   }
    //   output {
    //     traces  = [ otelcol.processor.batch.processorbatch.input]
    //   }
    // }
    