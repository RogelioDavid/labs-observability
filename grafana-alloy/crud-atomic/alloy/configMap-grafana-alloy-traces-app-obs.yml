apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-alloy-traces
  namespace: monitoring
data:
  config.alloy: |
    // Destination: rogmen-prom (prometheus)
    otelcol.exporter.prometheus "rogmen_prom" {
      add_metric_suffixes = true
      forward_to = [prometheus.remote_write.rogmen_prom.receiver]
    }
    
    prometheus.remote_write "rogmen_prom" {
      endpoint {
        url = "https://prometheus-us-central1.grafana.net/api/prom/push"
        headers = {
        }
        basic_auth {
          username = "821057"
          password = "eyJrIjoiNGRjNDU3MmQ1MTVlOTk2ODQ1Zjk1MGNmZDcwNGQyMmIwOGEwNjA3MyIsIm4iOiJyb2dtZW4tcHVibGlzaGVyIiwiaWQiOjgxNDMyMn0="
        }
        tls_config {
          insecure_skip_verify = false
        }
        send_native_histograms = false
    
        queue_config {
          capacity = 10000
          min_shards = 1
          max_shards = 50
          max_samples_per_send = 2000
          batch_send_deadline = "5s"
          min_backoff = "30ms"
          max_backoff = "5s"
          retry_on_http_429 = true
          sample_age_limit = "0s"
        }
    
        write_relabel_config {
          source_labels = ["cluster"]
          regex = ""
          replacement = "autopilot-cluster-app"
          target_label = "cluster"
        }
        write_relabel_config {
          source_labels = ["k8s.cluster.name"]
          regex = ""
          replacement = "autopilot-cluster-app"
          target_label = "cluster"
        }
      }
    
      wal {
        truncate_frequency = "2h"
        min_keepalive_time = "5m"
        max_keepalive_time = "8h"
      }
    }
    
  
    // Destination: rogmen-logs (loki)
    otelcol.exporter.loki "rogmen_logs" {
      forward_to = [loki.write.rogmen_logs.receiver]
    }
    
    loki.write "rogmen_logs" {
      endpoint {
        url = "https://logs-prod-017.grafana.net/loki/api/v1/push"
        basic_auth {
          username = 409497
          password = "eyJrIjoiNGRjNDU3MmQ1MTVlOTk2ODQ1Zjk1MGNmZDcwNGQyMmIwOGEwNjA3MyIsIm4iOiJyb2dtZW4tcHVibGlzaGVyIiwiaWQiOjgxNDMyMn0="
        }
        tls_config {
          insecure_skip_verify = false
        }
      }
      external_labels = {
        cluster = "autopilot-cluster-app",
        "k8s_cluster_name" = "autopilot-cluster-app",
      }
    }
    
   
    // Destination: rogmen-traces (otlp)
    otelcol.auth.basic "rogmen_traces" {
      username = 406010
      password = "eyJrIjoiNGRjNDU3MmQ1MTVlOTk2ODQ1Zjk1MGNmZDcwNGQyMmIwOGEwNjA3MyIsIm4iOiJyb2dtZW4tcHVibGlzaGVyIiwiaWQiOjgxNDMyMn0="
    }
    
    otelcol.processor.attributes "rogmen_traces" {
      output {
        metrics = [otelcol.processor.transform.rogmen_traces.input]
        logs = [otelcol.processor.transform.rogmen_traces.input]
        traces = [otelcol.processor.transform.rogmen_traces.input]
      }
    }
    
    otelcol.processor.transform "rogmen_traces" {
      error_mode = "ignore"
    
      trace_statements {
        context = "resource"
        statements = [
          `set(attributes["cluster"], "autopilot-cluster-app")`,
          `set(attributes["k8s.cluster.name"], "autopilot-cluster-app")`,
        ]
      }
    
      output {
        traces = [otelcol.processor.batch.rogmen_traces.input]
      }
    }
    
    otelcol.processor.batch "rogmen_traces" {
      timeout = "2s"
      send_batch_size = 8192
      send_batch_max_size = 0
    
      output {
        traces = [otelcol.exporter.otlp.rogmen_traces.input]
      }
    }
    otelcol.exporter.otlp "rogmen_traces" {
      client {
        endpoint = "https://tempo-us-central1.grafana.net:443"
        auth = otelcol.auth.basic.rogmen_traces.handler
        tls {
          insecure = false
          insecure_skip_verify = false
        }
      }
    }
    

    tracing {
      sampling_fraction = 0.8
      write_to = [otelcol.processor.tail_sampling.tail_sampling_default.input]
    }

    otelcol.processor.tail_sampling "tail_sampling_default" {
      decision_wait               = "10s"
      num_traces                  = 50000
      expected_new_traces_per_sec = 5000
      policy {
        name = "all_traces_above_1000ms"
        type = "latency"
        latency {
          threshold_ms = 1000
        }
      }
      policy {
        name = "sampling_percentage_probabilistic"
        type = "probabilistic"
        probabilistic {
            sampling_percentage = 10
        }
      }
      policy {
        name = "policy_status_code"
        type = "status_code"
        status_code {
          status_codes = ["ERROR", "UNSET"]
        }
      }
      policy {
        name = "policy_rate_limiting"
        type = "rate_limiting"
        rate_limiting {
          spans_per_second = 100
        }
      }	
      output {
        traces = [otelcol.exporter.otlp.rogmen_traces.input]
      }
    }



    // Feature: Application Observability
    declare "application_observability" {
      argument "metrics_destinations" {
        comment = "Must be a list of metrics destinations where collected metrics should be forwarded to"
      }
    
      argument "logs_destinations" {
        comment = "Must be a list of log destinations where collected logs should be forwarded to"
      }
    
      argument "traces_destinations" {
        comment = "Must be a list of trace destinations where collected trace should be forwarded to"
      }
    
      // OTLP Receiver
      otelcol.receiver.otlp "receiver" {
        grpc {
          endpoint = "0.0.0.0:4317"
        }
        http {
          endpoint = "0.0.0.0:4318"
        }
        debug_metrics {
          disable_high_cardinality_metrics = true
        }
        output {
          metrics = [otelcol.processor.resourcedetection.default.input]
          logs = [otelcol.processor.resourcedetection.default.input]
          traces = [otelcol.processor.memory_limiter.memory_limiter.input]
        }
      }
    
      // Zipkin Receiver
      otelcol.receiver.zipkin "receiver" {
        endpoint = "0.0.0.0:9411"
        debug_metrics {
          disable_high_cardinality_metrics = true
        }
        output {
          traces = [otelcol.processor.resourcedetection.default.input]
        }
      }

      otelcol.processor.memory_limiter "memory_limiter" {
        check_interval = "5s"
        limit = "400MiB"        // Hard Limit
        spike_limit = "100MiB"  // Soft Limit = Hard Limit - spike_limit = 300MiB
        output {
          traces  = [otelcol.processor.resourcedetection.default.input]
        }
      }       
    
      // Resource Detection Processor
      otelcol.processor.resourcedetection "default" {
        detectors = ["env","system"]
    
        system {
          hostname_sources = ["os"]
        }
    
        output {
          metrics = [otelcol.processor.k8sattributes.default.input]
          logs = [otelcol.processor.k8sattributes.default.input]
          traces = [otelcol.processor.k8sattributes.default.input]
        }
      }
    
      // K8s Attributes Processor
      otelcol.processor.k8sattributes "default" {
        extract {
          metadata = ["k8s.namespace.name","k8s.pod.name","k8s.deployment.name","k8s.statefulset.name","k8s.daemonset.name","k8s.cronjob.name","k8s.job.name","k8s.node.name","k8s.pod.uid","k8s.pod.start_time"]
        }
        pod_association {
          source {
            from = "resource_attribute"
            name = "k8s.pod.ip"
          }
          source {
            from = "resource_attribute"
            name = "k8s.pod.uid"
          }
          source {
            from = "connection"
          }
        }
    
        output {
          metrics = [otelcol.processor.transform.default.input]
          logs = [otelcol.processor.transform.default.input]
          traces = [otelcol.processor.transform.default.input, otelcol.connector.host_info.default.input]
        }
      }
    
      // Host Info Connector
      otelcol.connector.host_info "default" {
        host_identifiers = [ "k8s.node.name" ]
    
        output {
          metrics = [otelcol.processor.batch.default.input]
        }
      }
    
      // Transform Processor
      otelcol.processor.transform "default" {
        error_mode = "ignore"
        log_statements {
          context = "resource"
          statements = [
            "set(attributes[\"pod\"], attributes[\"k8s.pod.name\"])",
            "set(attributes[\"namespace\"], attributes[\"k8s.namespace.name\"])",
            "set(attributes[\"loki.resource.labels\"], \"cluster, namespace, job, pod\")",
          ]
        }
    
        output {
          metrics = [otelcol.processor.batch.default.input]
          logs = [otelcol.processor.batch.default.input]
          traces = [otelcol.processor.filter.filterdefault.input]
        }
      }

    otelcol.processor.filter "filterdefault" {
      error_mode = "ignore"
      traces {
        span = [
          "IsMatch(attributes[\"http.route\"], \".*prometheus.*\")",
          "IsMatch(attributes[\"http.route\"], \".*health.*\")",
          "IsMatch(attributes[\"http.target\"], \".*health.*\")",
          "IsMatch(attributes[\"http.target\"], \".*health_check.*\")",
          "IsMatch(attributes[\"db.operation\"], \".*PING.*\")",
          "IsMatch(attributes[\"express.type\"], \".*middleware.*\")",
          "IsMatch(attributes[\"express.type\"], \".*router.*\")",
          "IsMatch(attributes[\"db.operation\"], \".*EXIST.*\")",
          "IsMatch(attributes[\"express.name\"], \".*request handler.*\")",
          "IsMatch(attributes[\"net.peer.port\"], \".*9000.*\")",
          "IsMatch(attributes[\"db.system\"], \".*redis.*\")",
        ]
      }

      output {
        traces = [otelcol.processor.batch.default.input]
      }
    }    

      // Batch Processor
      otelcol.processor.batch "default" {
        send_batch_size = 8192
        send_batch_max_size = 0
        timeout = "2s"
    
        output {
          metrics = argument.metrics_destinations.value
          logs = argument.logs_destinations.value
          traces = argument.traces_destinations.value
        }
      }
    }
    application_observability "feature" {
      metrics_destinations = [
        otelcol.exporter.prometheus.rogmen_prom.input,
      ]
      logs_destinations = [
        otelcol.exporter.loki.rogmen_logs.input,
      ]
      traces_destinations = [
        otelcol.processor.attributes.rogmen_traces.input,
      ]
    }